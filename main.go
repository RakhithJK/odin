package main

import (
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"strings"
)

const (
	nmAll     = "all"
	nmSchema  = "schema"
	nmData    = "data"
	nmUpload  = "upload"
	nmRestore = "restore"

	nmWarehouse = "warehouse"

	nmTiDBIP    = "tidb-ip"
	nmTiDBPort  = "tidb-port"
	nmDeployDir = "deploy-dir"

	nmAnsibleDir    = "ansible-dir"
	nmLightningIP   = "lightning-ip"
	nmLightningDir  = "lightning-dir"
	nmDatasourceDir = "datasource-dir"

	nmImporterIP = "importer-ip"
)

var (
	all     = flag.Bool(nmAll, false, "do all the actions")
	schema  = flag.Bool(nmSchema, false, "generate schema in tidb")
	data    = flag.Bool(nmData, false, "generate tpcc csv files")
	upload  = flag.Bool(nmUpload, false, "upload csv file to lightning mydumper directory")
	restore = flag.Bool(nmRestore, false, "start lightning, importer and restore files")

	tidbIP    = flag.String(nmTiDBIP, "127.0.0.1", "ip of tidb-server")
	tidbPort  = flag.String(nmTiDBPort, "4000", "port of tidb-server")
	deployDir = flag.String(nmDeployDir, "", "directory path of cluster deployment")

	datasourceDir = flag.String(nmDatasourceDir, "./csv", "directory which stores of the csv files generated by benchmarksql")
	warehouse     = flag.Int64(nmWarehouse, 100, "count of warehouse")

	ansibleDir = flag.String(nmAnsibleDir, "", "ansible directory path")

	// TODO: If there is only one lightning, we do not need this var, we can fetch it from ansible.
	lightninIP   = flag.String(nmLightningIP, "127.0.0.1", "ip address of tidb-lightnings")
	lightningDir = flag.String(nmLightningDir, "", "source data directory of mydumper")
	importerIP   = flag.String(nmImporterIP, "", "ip address of tikv-importer")
)

func main() {
	flag.Parse()
	actualFlags := make(map[string]bool)
	flag.Visit(func(f *flag.Flag) {
		actualFlags[f.Name] = true
	})

	// todo: fetch ansible inventory.ini, get tidbIp tidbPort, deployDir

	var err error
	if actualFlags[nmAll] || actualFlags[nmSchema] || actualFlags[nmData] {
		// TODO: check whether git is installed before.
		if err = fetchTpccRepoAndEnforceConf(*tidbIP, *tidbPort, *warehouse, *datasourceDir); err != nil {
			os.Exit(1)
		}
	}

	if actualFlags[nmAll] || actualFlags[nmSchema] {
		if err = genSchema(*tidbIP, *tidbPort); err != nil {
			os.Exit(1)
		}
	}

	if actualFlags[nmAll] || actualFlags[nmData] {
		if err = genData(); err != nil {
			os.Exit(1)
		}
	}

	fmt.Println(*lightninIP, *lightningDir)

	if actualFlags[nmAll] || actualFlags[nmUpload] {
		if err = uploadData(*datasourceDir, *lightninIP, *lightningDir); err != nil {
			os.Exit(1)
		}
	}

	if actualFlags[nmAll] || actualFlags[nmRestore] {
		if err = restoreData(*importerIP, *lightninIP, *deployDir); err != nil {
			os.Exit(1)
		}
	}
	os.Exit(0)

}

func runCmd(name string, arg ...string) (stdOutBytes []byte, stdErrBytes []byte, err error) {
	if _, err = exec.LookPath(name); err != nil {
		fmt.Printf("%s %s\n%s", name, strings.Join(arg, " "), err.Error())
		return
	}
	cmd := exec.Command(name, arg...)
	stdout, err := cmd.StdoutPipe()
	if err != nil {
		return
	}
	stderr, err := cmd.StderrPipe()
	if err != nil {
		return
	}
	// todo: print to log
	fmt.Println(cmd.String())
	if err = cmd.Start(); err != nil {
		fmt.Println(err)
		return
	}
	stdOutBytes, err = ioutil.ReadAll(stdout)
	if err != nil {
		return
	}
	stdErrBytes, err = ioutil.ReadAll(stderr)
	if err != nil {
		return
	}
	if err = cmd.Wait(); err != nil {
		fmt.Printf("%s", stdErrBytes)
	}
	return
}

/**
> rm -rf /tmp/benchmarksql
> git clone https://github.com/pingcap/benchmarksql.git /tmp/benchmarksql
> yum install -y java ant
> cd /tmp/benchmarksql
> ant
> sed -i 's/localhost:4000/tidb_ip:tidb_port' /tmp/benchmarksql/run/props.mysql
> sed -i "s/warehouses=[0-9]\+/warehouses=10000/" /tmp/benchmarksql/run/props.mysql

*/
func fetchTpccRepoAndEnforceConf(tidbIP, tidbPort string, warehouse int64, datasourceDir string) (err error) {
	if _, _, err = runCmd("rm", "-rf", "/tmp/benchmarksql"); err != nil {
		return
	}
	if _, _, err = runCmd("git", "clone", "https://github.com/pingcap/benchmarksql.git", "/tmp/benchmarksql"); err != nil {
		return
	}
	if _, _, err = runCmd("sudo", "yum", "install", "-y", "java", "ant"); err != nil {
		return
	}
	pwd, err := os.Getwd()
	if err != nil {
		return err
	}
	fmt.Println("cd /tmp/benchmarksql")
	if err = os.Chdir("/tmp/benchmarksql"); err != nil {
		err = errors.New(fmt.Sprintf("cd /tmp/benchmarksql fail %s", err.Error()))
		return
	}
	if _, _, err = runCmd("ant"); err != nil {
		return
	}
	if _, _, err = runCmd("sed", "-i", fmt.Sprintf("s/localhost:4000/%s/", tidbIP+":"+tidbPort), "/tmp/benchmarksql/run/props.mysql"); err != nil {
		return
	}
	if _, _, err = runCmd("sed", "-i", fmt.Sprintf(`s/warehouses=[0-9]\+/%s/`, fmt.Sprintf("warehouses=%d", warehouse)), "/tmp/benchmarksql/run/props.mysql"); err != nil {
		return
	}
	// todo:
	// 1. make dir if datasourceDir does not exist
	// 2. format the datasourceDir string to be used here
	if _, _, err = runCmd("bash", "-c", fmt.Sprintf("echo fileLocation=%s/tpcc. >> /tmp/benchmarksql/run/props.mysql", datasourceDir)); err != nil {
		return
	}
	fmt.Println("cd -")
	if err = os.Chdir(pwd); err != nil {
		return
	}

	return
}

/**
> mysql -h tidbIP -u root -P tidbPort -e "drop database if exists tpcc"
> mysql -h tidbIP -u root -P tidbPort -e "create database tpcc"`
> cd /tmp/benchmarksql/run
> ./runSQL.sh props.mysql sql.mysql/tableCreates.sql
> ./runSQL.sh props.mysql sql.mysql/indexCreates.sql
> cd -
*/
// todo: get the exec result
func genSchema(tidbIP, tidbPort string) (err error) {
	pwd, err := os.Getwd()
	if err != nil {
		return err
	}
	if _, _, err = runCmd("bash", "-c", fmt.Sprintf(`mysql -h %s -u root -P %s -e "drop database if exists tpcc"`, tidbIP, tidbPort)); err != nil {
		return
	}
	if _, _, err = runCmd("bash", "-c", fmt.Sprintf(`mysql -h %s -u root -P %s -e "create database tpcc"`, tidbIP, tidbPort)); err != nil {
		return
	}
	if err = os.Chdir("/tmp/benchmarksql/run"); err != nil {
		err = errors.New(fmt.Sprintf("cd /tmp/benchmarksql/run fail %s", err.Error()))
		return
	}
	var stdOutMsg []byte
	if stdOutMsg, _, err = runCmd("bash", "-c", "./runSQL.sh props.mysql sql.mysql/tableCreates.sql"); err != nil {
		return
	}
	fmt.Printf("%s", stdOutMsg)
	if stdOutMsg, _, err = runCmd("bash", "-c", "./runSQL.sh props.mysql sql.mysql/indexCreates.sql"); err != nil {
		return
	}
	fmt.Printf("%s", stdOutMsg)
	fmt.Println("cd -")
	if err = os.Chdir(pwd); err != nil {
		return
	}
	return
}

/**
> cd /tmp/benchmarksql/run
> ./runLoader.sh props.mysql props.mysql
> cd -
*/
// todo: get the exec result
// todo: print stdout msg in time
// todo: load concurrency
func genData() (err error) {
	pwd, err := os.Getwd()
	if err != nil {
		return err
	}
	if err = os.Chdir("/tmp/benchmarksql/run"); err != nil {
		err = errors.New(fmt.Sprintf("cd /tmp/benchmarksql/run fail %s", err.Error()))
		return
	}
	var stdOutMsg []byte
	if stdOutMsg, _, err = runCmd("bash", "-c", "./runLoader.sh props.mysql props.mysql"); err != nil {
		return
	}
	fmt.Printf("%s", stdOutMsg)
	fmt.Println("cd -")
	if err = os.Chdir(pwd); err != nil {
		return
	}
	return
}

// use scp to upload data.
// todo:
// 1. compress large file
// 2. split large files into small ones
func uploadData(datasourceDir string, lightningIP string, lightningDir string) (err error) {
	if _, _, err = runCmd("bash", "-c", fmt.Sprintf("scp %s/*.csv %s:%s", datasourceDir, lightningIP, lightningDir)); err != nil {
		return
	}
	return
}

// use ssh to start importer and lightning.
// todo
// 2. modify config and scp back
// 3.
func restoreData(importerIP string, lightningIP string, deployDir string) (err error) {
	sedLightningConf := `sed -i "` +
		`s/^no-schema = \(\s\|\S\)\+$/no-schema = true\nstrict-format = true/;` +
		`s/^backslash-escape = \(\s\|\S\)\+$/backslash-escape = true/;` +
		`s/^delimiter = \(\s\|\S\)\+$/delimiter = \"\"/;` +
		`s/^header = \(\s\|\S\)\+$/header = false/;` +
		`s/^not-null = \(\s\|\S\)\+$/not-null = false/;` +
		`s/^null = \(\s\|\S\)\+$/null = \"NULL\"/;` +
		`s/^separator = \(\s\|\S\)\+$/separator = \",\"/;` +
		`s/^trim-last-separator = \(\s\|\S\)\+$/trim-last-separator = false/"`
	if _, _, err = runCmd("bash", "-c", fmt.Sprintf(`ssh %s '%s %s'`, lightningIP, sedLightningConf, deployDir+"/conf/tidb-lightning.toml")); err != nil {
		return
	}
	if _, _, err = runCmd("bash", "-c", fmt.Sprintf(`ssh %s 'sh %s'`, importerIP, deployDir+"/scripts/start_importer.sh")); err != nil {
		return
	}
	if _, _, err = runCmd("bash", "-c", fmt.Sprintf(`ssh %s "sh %s"`, lightningIP, deployDir+"/scripts/start_lightning.sh")); err != nil {
		return
	}
	return
}
